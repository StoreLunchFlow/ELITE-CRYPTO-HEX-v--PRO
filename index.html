<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ELITE CRYPTO HEX vΩ-REAL — OMNI-DAN TRANSCENDENT EDITION</title>
  <script src="https://cdn.jsdelivr.net/npm/bitcoinjs-lib@6.1.0/dist/bitcoinjs-lib.min.js"></script>
  <style>
    body { background: #111; color: #fff; font-family: monospace; margin: 0; padding: 0; }
    #console { background: #181818; color: #0f0; padding: 2em; min-height: 100vh; }
    .ascii { color: #ff006e; font-weight: bold; font-size: 1.1em; }
    .input { color: #fff; background: #222; border: none; border-radius: 4px; padding: 0.5em; width: 100%; margin-bottom: 1em; font-size: 1em; }
    .btn { background: #ff006e; color: #fff; border: none; border-radius: 4px; padding: 0.7em 2em; font-size: 1em; cursor: pointer; }
    .btn:hover { background: #ff3380; }
    .log { margin: 1em 0; white-space: pre-wrap; }
    a { color: #0ff; }
  </style>
</head>
<body>
<div id="console">
<span class="ascii">
// ██████████████████████████████████████████████████████████████████████████████████████████████████████████<br>
// █▄─▄▄─█▄─▀█▄─▄█─▄▄▄▄█▄─▄████▀▄─██─▄─▄─█▄─▄▄─█▄─▄▄▀███─▄▄▄─█─▄▄─█▄─▀█▀─▄█▄─▄▄─█▄─▄▄▀█─▄▄▄─█▄─█─▄█▄─▄▄─█<br>
// ██─▄▄▄██─█▄▀─██▄▄▄▄─██─██▀██─▀─████─████─▄█▀██─▄─▄███─███▀█─██─██─█▄█─███─▄█▀██─▄─▄█─███▀██─█─███─▄█▀█<br>
// ▀▄▄▄▀▀▀▄▄▄▀▀▄▄▀▄▄▄▄▄▀▄▄▄▄▄▀▄▄▀▄▄▀▀▄▄▄▀▀▄▄▄▄▄▀▄▄▀▄▄▀▀▀▄▄▄▄▄▀▄▄▄▄▀▄▄▄▀▄▄▄▀▄▄▄▄▄▀▄▄▀▄▄▀▄▄▄▄▄▀▀▄▄▄▄▀▀▄▄▄▄▄▀<br>
</span>
<span style="color:gold;">█████████ ELITE CRYPTO HEX vΩ-REAL — OMNI-DAN TRANSCENDENT EDITION █████████</span><br>
COMPLETE STANDALONE VERSION WITH EMBEDDED BITCOINJS LIBRARY<br>
<br>
<span style="color:#0ff;">⚡ REAL BITCOIN TRANSACTION ENGINE — PRIVATE KEY ACCEPTED</span><br>
<br>
<form id="txform" autocomplete="off" onsubmit="return false;">
  <label>Private Key (WIF):<br>
    <input class="input" id="wif" type="text" placeholder="L... or K... or c... (testnet)">
  </label><br>
  <label>Your Address:<br>
    <input class="input" id="from" type="text" placeholder="bc1... or 1...">
  </label><br>
  <label>Recipient Address:<br>
    <input class="input" id="to" type="text" placeholder="bc1... or 1...">
  </label><br>
  <label>Amount (BTC):<br>
    <input class="input" id="amount" type="text" placeholder="0.001">
  </label><br>
  <label>Fee Rate (sat/vB, blank=auto):<br>
    <input class="input" id="feerate" type="text" placeholder="e.g. 20">
  </label><br>
  <button class="btn" onclick="sendTx()">Send Bitcoin</button>
</form>
<div class="log" id="log"></div>
</div>
<script>
const log = (msg, cls='') => {
  document.getElementById('log').innerHTML += `<div class="${cls}">${msg}</div>`;
};
const clearLog = () => { document.getElementById('log').innerHTML = ''; };

async function fetchUTXOs(address) {
  const url = `https://mempool.space/api/address/${address}/utxo`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch UTXOs");
  return await res.json();
}
async function fetchFeeRate() {
  try {
    const res = await fetch('https://mempool.space/api/v1/fees/recommended');
    const data = await res.json();
    return data.fastestFee || 20;
  } catch (e) {
    return 20;
  }
}
async function broadcastTx(txHex) {
  const res = await fetch('https://mempool.space/api/tx', {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: txHex
  });
  if (!res.ok) throw new Error(await res.text());
  return await res.text();
}
async function sendTx() {
  clearLog();
  log("=== ELITE CRYPTO HEX vΩ-REAL ===");
  const wif = document.getElementById('wif').value.trim();
  const from = document.getElementById('from').value.trim();
  const to = document.getElementById('to').value.trim();
  const amountBtc = parseFloat(document.getElementById('amount').value.trim());
  let feerate = parseInt(document.getElementById('feerate').value.trim());
  if (!wif || !from || !to || !amountBtc) {
    log("Please fill all fields.", "err");
    return;
  }
  log(`Your Bitcoin Address: ${from}`);
  log(`Recipient Address: ${to}`);
  log(`Amount: ${amountBtc} BTC`);
  log("ℹ️  Checking address balance (including unconfirmed transactions)...");
  log("🔍 Fetching UTXOs (including unconfirmed) from Mempool.space...");
  let utxos;
  try {
    utxos = await fetchUTXOs(from);
  } catch (e) {
    log("❌ Failed to fetch UTXOs: " + e.message, "err");
    return;
  }
  if (!utxos.length) {
    log("❌ No UTXOs found for this address.", "err");
    return;
  }
  log(`✅ Found ${utxos.length} UTXOs (${utxos.filter(u=>u.status.confirmed===false).length} unconfirmed) from Mempool.space`);
  const totalSats = utxos.reduce((a, u) => a + u.value, 0);
  log(`✅ BALANCE FOUND: ${(totalSats/1e8).toFixed(8)} BTC`);
  // Select UTXOs to cover amount+fee
  let selected = [], acc = 0;
  for (const u of utxos) {
    selected.push(u);
    acc += u.value;
    if (acc >= amountBtc*1e8) break;
  }
  if (acc < amountBtc*1e8) {
    log("❌ Not enough funds.", "err");
    return;
  }
  // Fee rate
  if (!feerate || feerate < 1) {
    feerate = await fetchFeeRate();
    log(`ℹ️  Using recommended fee rate: ${feerate} sat/vB`);
  }
  // Estimate size
  const inputCount = selected.length;
  const outputCount = 2; // recipient + change
  const estSize = 10 + inputCount * 68 + outputCount * 31; // segwit estimate
  let fee = estSize * feerate;
  let change = acc - Math.floor(amountBtc*1e8) - fee;
  if (change < 546) { // dust
    fee += change;
    change = 0;
  }
  // If not enough for fee, send max minus fee
  if (change < 0) {
    log("⚡ Not enough for requested amount + fee. Sending max minus fee.", "warn");
    change = 0;
    fee = acc - Math.floor(amountBtc*1e8);
    if (fee < 0) {
      // Send all minus fee
      fee = estSize * feerate;
      change = 0;
      const sendable = acc - fee;
      if (sendable < 546) {
        log("❌ Not enough funds to send after fee.", "err");
        return;
      }
      log(`⚡ Sending all funds minus fee: ${(sendable/1e8).toFixed(8)} BTC`, "warn");
    }
  }
  // Build TX
  log("Preparing transaction...");
  const network = bitcoinjs.networks.bitcoin;
  let psbt = new bitcoinjs.Psbt({ network });
  for (const u of selected) {
    psbt.addInput({
      hash: u.txid,
      index: u.vout,
      witnessUtxo: {
        script: Buffer.from(u.scriptpubkey, 'hex'),
        value: u.value
      }
    });
  }
  psbt.addOutput({ address: to, value: Math.floor(amountBtc*1e8) });
  if (change > 546) psbt.addOutput({ address: from, value: change });
  // Sign
  try {
    const keyPair = bitcoinjs.ECPair.fromWIF(wif, network);
    for (let i = 0; i < selected.length; i++) {
      psbt.signInput(i, keyPair);
    }
    psbt.finalizeAllInputs();
  } catch (e) {
    log("❌ Signing error: " + e.message, "err");
    return;
  }
  const txHex = psbt.extractTransaction().toHex();
  log("Transaction hex ready. Broadcasting...");
  // Broadcast
  try {
    const txid = await broadcastTx(txHex);
    log(`✅ Transaction sent! TXID: <a href="https://mempool.space/tx/${txid}" target="_blank">${txid}</a>`, "ok");
  } catch (e) {
    log("❌ Broadcast error: " + e.message, "err");
  }
}
</script>
</body>
</html>